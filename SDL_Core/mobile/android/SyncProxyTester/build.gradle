apply plugin: 'android'

repositories {
    mavenCentral()
}

dependencies {
    compile fileTree(dir: 'libs', include: '*.jar')
    compile project(':SyncProxyAndroid')
    compile project(':FileExplorer')
    instrumentTestCompile 'com.google.dexmaker:dexmaker-mockito:1.0'
}

def isReleaseSigningSetup = false

android {
    compileSdkVersion rootProject.compileSdkVersion
    buildToolsVersion rootProject.buildToolsVersion



    sourceSets {
        instrumentTest {
            java.srcDirs = ['instrumentTest/java']
        }
    }

    lintOptions {
        // Don't abort if Lint finds an error, otherwise the Jenkins build
        // will be marked as failed, and Jenkins won't analyse the Lint output
        abortOnError false
    }

    def flavorNames = ["Alice", "Sandy", "Kate", "Caroline", "Amy"]

    productFlavors {
        mainFlavor {
        }

        flavorNames.each {
            def fullFlavorName = "spt" + it + "Flavor"
            def packageFlavorName = "com.ford.syncV4.SPT" + it
            "${fullFlavorName}" {
                packageName "${packageFlavorName}"
            }
        }
    }
    def expandTilde = {path ->
        if (path.startsWith("~" + File.separator)) {
            path = System.getProperty("user.home") + path.substring(1)
        }
        file(path)
    }
    def projectPropertiesFilename = "spt.properties"

    // http://stackoverflow.com/questions/18328730/how-to-create-a-release-signed-apk-file-using-gradle
    if (project.hasProperty(projectPropertiesFilename)) {
        def propertiesFilename = expandTilde(project.property(projectPropertiesFilename))

        if (propertiesFilename.exists()) {
            Properties props = new Properties()
            props.load(new FileInputStream(propertiesFilename))

            signingConfigs {
                release {
                    storeFile expandTilde(props["storeFile"])
                    storePassword props["storePassword"]
                    keyAlias props["keyAlias"]
                    keyPassword props["keyPassword"]
                }
            }

            buildTypes {
                release {
                    signingConfig signingConfigs.release
                }
            }
            isReleaseSigningSetup = true
        }
    }
}

if (!isReleaseSigningSetup) {
    logger.warn("Couldn't configure signing for release builds!")
}


task saveBuildInfo {
    description = "Saves the build info (current git branch/tag, commit hash, and build time)"

    doFirst {
        def git_version = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'log', '-1', '--format=%h'
            standardOutput = git_version
        }
        git_version = git_version.toString().trim()

        def git_branch = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'symbolic-ref', '--short', '-q', 'HEAD'
            standardOutput = git_branch
            // ignore error output as we might not be on a branch
            ignoreExitValue = true
        }

        def git_branch_or_tag
        if (git_branch.size() > 0) {
            git_branch_or_tag = git_branch.toString().trim()
        } else {
            def git_tag = new ByteArrayOutputStream()
            exec {
                commandLine 'git', 'describe', '--tags', '--exact-match'
                standardOutput = git_tag
                // ignore error output
                errorOutput = new ByteArrayOutputStream()
                ignoreExitValue = true
            }

            git_branch_or_tag = git_tag.toString().trim()
        }

        def build_time = new Date().toString()

        def result_line = git_branch_or_tag + "-" + git_version + " (" +
                build_time + ")\n"
        def assetsDir = android.sourceSets.main.assets.srcDirs.toArray()[0]
        def buildInfoFile = new File(assetsDir, 'build.info').getAbsolutePath()
        new File(buildInfoFile).write(result_line)
    }
}

gradle.projectsEvaluated {
    android.productFlavors.each { flavor ->
        def flavorName = flavor.name.capitalize()
        def flavorPackageTask = tasks.getByPath("package${flavorName}Debug")
        flavorPackageTask.dependsOn(saveBuildInfo)
    }
}
